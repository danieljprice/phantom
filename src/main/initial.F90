!--------------------------------------------------------------------------!
! The Phantom Smoothed Particle Hydrodynamics code, by Daniel Price et al. !
! Copyright (c) 2007-2025 The Authors (see AUTHORS)                        !
! See LICENCE file for usage and distribution conditions                   !
! http://phantomsph.github.io/                                             !
!--------------------------------------------------------------------------!
module initial
!
! This module initialises (and ends) the run
!
! :References: None
!
! :Owner: Daniel Price
!
! :Runtime parameters: None
!
! :Dependencies: HIIRegion, analysis, apr, boundary, boundary_dyn,
!   centreofmass, checkconserved, checkoptions, checksetup, cons2prim,
!   cooling, cpuinfo, densityforce, deriv, dim, dust, dust_formation,
!   dynamic_dtmax, energies, eos, evwrite, extern_gr, externalforces,
!   fileutils, forcing, growth, inject, io, io_control, io_summary, metric,
!   metric_et_utils, metric_tools, mf_write, mpibalance, mpidomain,
!   mpimemory, mpitree, mpiutils, neighkdtree, nicil, nicil_sup, omputils,
!   options, part, partinject, porosity, ptmass, radiation_utils,
!   readwrite_dumps, readwrite_infile, subgroup, timestep, timestep_ind,
!   timing, units, writeheader
!

 implicit none
 public :: initialise,finalise,startrun,endrun
 real(kind=4), private :: twall_start, tcpu_start

 private

contains

!----------------------------------------------------------------
!+
!  short initialisation routine that should be called
!  by any utility which will subsequently call derivs
!+
!----------------------------------------------------------------
subroutine initialise()
 use dim,              only:mpi,gr
 use io,               only:fatal,id,master,nprocs,ievfile
 use omputils,         only:init_omp,info_omp
 use options,          only:set_default_options
 use io_summary,       only:summary_initialise
 use boundary,         only:set_boundary
 use writeheader,      only:write_codeinfo
 use evwrite,          only:init_evfile
 use mpidomain,        only:init_domains
 use cpuinfo,          only:print_cpuinfo
 use checkoptions,     only:check_compile_time_settings
 use metric,           only:metric_type
 use metric_et_utils,  only:read_tabulated_metric,gridinit
 integer :: ierr

!
!--write 'PHANTOM' and code version
!
 if (id==master) call write_codeinfo(6)
!
!--set default options (incl. units)
!
 call set_default_options
 call set_boundary
 call init_evfile(ievfile,'testlog',.false.)
!
!--initialise values for summary array
!
 call summary_initialise
!
!--check compile-time settings are OK
!
 call check_compile_time_settings(ierr)
 if (ierr /= 0) call fatal('initialise','incompatible compile-time settings')
!
!--initialise openMP things if required
!
 if (id==master) call print_cpuinfo()
 if (id==master) call info_omp
 call init_omp
!
!--initialise MPI domains
!
 call init_domains(nprocs)
!
!--initialise metric if tabulated
!
 if (gr .and. metric_type=='et') then
    call read_tabulated_metric('tabuled_metric.dat',ierr)
    if (ierr == 0) gridinit = .true.
 endif

end subroutine initialise

!----------------------------------------------------------------
!+
!  routine which starts a Phantom run
!+
!----------------------------------------------------------------
subroutine startrun(infile,logfile,evfile,dumpfile,noread)
 use dim,              only:maxp,maxalpha,nalpha,mpi,ind_timesteps,inject_parts
 use io,               only:iprint,flush_warnings,fatal,id,master
 use boundary_dyn,     only:dynamic_bdy,init_dynamic_bdy
 use centreofmass,     only:get_centreofmass,print_particle_extent
 use dynamic_dtmax,    only:get_dtmax_initial
 use energies,         only:xyzcom
 use inject,           only:init_inject,inject_particles
 use options,          only:write_files
 use mpibalance,       only:balancedomains
 use mpiutils,         only:reduceall_mpi
 use part,             only:npart,npartoftype,alphaind,ntot,update_npartoftypetot,&
                            iamtype,igas,nptmass,xyzmh_ptmass,vxyz_ptmass,&
                            xyzh,vxyzu,ibin,ibin_old,ibin_wake,ibelong
 use partinject,       only:update_injected_particles
 use readwrite_dumps,  only:dt_read_in
 use timing,           only:get_timings
 use timestep,         only:time,dt,dtextforce,dtcourant,dtforce,dtinject,dtmax
 use timestep_ind,     only:ibinnow,init_ibin,istepfrac,nbinmax
 use writeheader,      only:write_header
 character(len=*), intent(in)  :: infile
 character(len=*), intent(out) :: logfile,evfile,dumpfile
 logical,          intent(in), optional :: noread
 integer :: ierr,i
 real    :: dtnew_first,dtsinkgas,dummy(3)
 logical :: read_files,iexist
 integer :: npart_old
 character(len=len(dumpfile)) :: file1D

 read_files = .true.
 if (present(noread)) read_files = .not.noread

 ! read parameters from the infile and the initial conditions from the dumpfile
 if (read_files) call read_infile_and_initial_conditions(infile,logfile,evfile,dumpfile,time,ierr)

 ! get total number of particles (on all processors)
 ntot = reduceall_mpi('+',npart)
 call update_npartoftypetot
 if (id==master) write(iprint,"(a,i12)") ' npart total   = ',ntot
 if (npart > 0) then
    if (id==master .and. maxalpha==maxp)  write(iprint,*) 'mean alpha  initial: ',sum(alphaind(1,1:npart))/real(npart)
 endif

 ! reset dtmax if required
 call get_dtmax_initial(dtmax)

 ! initialise dynamic boundaries in the first instance
 if (dynamic_bdy) call init_dynamic_bdy(1,npart,nptmass,dtmax)

 ! initialize physics parameters and equation of state
 call initialise_physics_modules(dumpfile,infile,time,ierr)
 if (ierr /= 0) call fatal('initial','error in physics setup')

 ! get density and initialise B/rho and dust evolution variables
 call get_density_and_initialise_conservative_variables()

 if (ind_timesteps) then
    ibin(:)       = 0
    ibin_old(:)   = 0
    ibin_wake(:)  = 0
    if (dt_read_in) call init_ibin(npart,dtmax)
    istepfrac     = 0
    ibinnow       = 0
 else
    dtcourant = huge(dtcourant)
    dtforce   = huge(dtforce)
 endif
 dtinject  = huge(dtinject)

 !
 ! balance domains prior to starting calculation
 ! (make sure this is called AFTER iphase has been set)
 !
 if (mpi) then
    do i=1,npart
       ibelong(i) = id
    enddo
    call balancedomains(npart)
 endif

 ! setup external forces and get timestep constraint
 call initialise_external_forces_and_gr(time,dtextforce,ierr)
 if (ierr /= 0) call fatal('initial','error in external force setup')

 ! get sink particle forces and calculate timestep constraints
 call initialise_sink_particle_forces(time,dtextforce,dtsinkgas,logfile,ierr)
 if (ierr /= 0) call fatal('initial','error in sink particle setup')

 ! inject particles at t=0, and get timestep constraint on this
 if (inject_parts) then
    call init_inject(ierr)
    if (ierr /= 0) call fatal('initial','error initialising particle injection')
    npart_old = npart
    call inject_particles(time,0.,xyzh,vxyzu,xyzmh_ptmass,vxyz_ptmass,&
                          npart,npart_old,npartoftype,dtinject)
    call update_injected_particles(npart_old,npart,istepfrac,nbinmax,time,dtmax,dt,dtinject)
 endif

#ifdef KROME
 ! set initial chemical abundance values
 call initialise_krome()
 dtextforce = min(dtextforce,dtmax/2.0**10)  ! Required since a cooling timestep is not initialised for implicit cooling
#endif

 ! calculate initial derivatives (density, SPH forces, etc.)
 call get_derivs_initial(time,dumpfile,ntot,dtnew_first,ierr)
 if (ierr /= 0) call fatal('initial','error in derivatives setup')

 ! set initial timestep
 if (.not.ind_timesteps) then
    dt = min(dtnew_first,dtinject)
    if (id==master) then
       write(iprint,*) 'dt(forces)    = ',dtforce
       write(iprint,*) 'dt(courant)   = ',dtcourant
       write(iprint,*) 'dt initial    = ',dt
    endif
 endif

 ! initialise dynamic boundaries in the second instance
 if (dynamic_bdy) call init_dynamic_bdy(2,npart,nptmass,dtmax)

 ! calculate current centre of mass
 call get_centreofmass(xyzcom,dummy,npart,xyzh,vxyzu,nptmass,xyzmh_ptmass,vxyz_ptmass)

 ! write second header to logfile/screen
 if (id==master .and. read_files) call write_header(2,infile,evfile,logfile,dumpfile,ntot)

 ! setup conservation and output
 call get_energies_and_init_ev_files(infile,evfile,logfile,time,dt)

 ! print extent of the particle distribution
 call print_particle_extent()  ! must call this from all MPI threads otherwise will hang

 ! initialise conservation checks
 call init_conservation_checks()

 ! write initial dump file (replacing .tmp) and update infile
 call write_initial_dump(time,dumpfile,infile,logfile,evfile)

 if (id==master) then
    call flush_warnings()
    call flush(iprint)

    ! get starting cpu time
    call get_timings(twall_start,tcpu_start)
 endif

end subroutine startrun

!----------------------------------------------------------------
!+
!  Handle file reading and initial setup
!+
!----------------------------------------------------------------
subroutine read_infile_and_initial_conditions(infile,logfile,evfile,dumpfile,time,ierr)
 use io,               only:iprint,id,master,nprocs,idisk1
 use readwrite_infile, only:read_infile
 use readwrite_dumps,  only:read_dump
 use checksetup,       only:check_setup
 use writeheader,      only:write_codeinfo,write_header
 use cpuinfo,          only:print_cpuinfo
 use io,               only:fatal,warning
 use dim,              only:idumpfile
 character(len=*), intent(in)    :: infile
 character(len=*), intent(inout) :: logfile,evfile,dumpfile
 real,             intent(out)   :: time
 integer,          intent(out)   :: ierr
 integer :: nerr,nwarn,irestart
 real :: hfactfile

 ierr = 0

 ! do preliminary initialisation
 call initialise

 ! read parameters from infile
 call read_infile(infile,logfile,evfile,dumpfile)

 ! initialise log output
 if (iprint /= 6 .and. id==master) then
    open(unit=iprint,file=logfile,form='formatted',status='replace')
    ! write opening "splash screen" to logfile
    call write_codeinfo(iprint)
    call print_cpuinfo(iprint)
 endif
 if (id==master) write(iprint,"(a)") ' starting run '//trim(infile)

 if (id==master) call write_header(1,infile,evfile,logfile,dumpfile)

 ! read particle setup from dumpfile
 call read_dump(trim(dumpfile),time,hfactfile,idisk1,iprint,id,nprocs,ierr)
 if (ierr /= 0) call fatal('initial','error reading dumpfile')
 call check_setup(nerr,nwarn,restart=.true.) ! sanity check what has been read from file
 if (nwarn > 0) then
    print "(a)"
    call warning('initial','WARNINGS from particle data in file',var='# of warnings',ival=nwarn)
 endif
 if (nerr > 0) call fatal('initial','errors in initial setup',var='errors',ival=nerr)

 ! if starting from a restart dump, rename the dumpfile to that of the previous non-restart dump
 irestart = index(dumpfile,'.restart')
 if (irestart > 0) write(dumpfile,'(2a,i5.5)') dumpfile(:irestart-1),'_',idumpfile

end subroutine read_infile_and_initial_conditions

!----------------------------------------------------------------
!+
!  Initialize physical parameters and equation of state
!+
!----------------------------------------------------------------
subroutine initialise_physics_modules(dumpfile,infile,time,ierr)
 use dim,            only:mhd_nonideal,gr,driving,use_dust,use_dustgrowth,use_apr,&
                          update_muGamma,itau_alloc,itauL_alloc,do_nucleation
 use io,             only:id,master,iprint,error,fatal
 use apr,            only:init_apr
 use cooling,        only:init_cooling
 use dust,           only:init_drag
 use forcing,        only:init_forcing
 use growth,         only:init_growth
 use porosity,       only:init_porosity,init_filfac
 use eos,            only:init_eos,ieos,gmw,gamma
 use nicil,          only:nicil_initialise
 use nicil_sup,      only:use_consistent_gmw
 use dust_formation, only:init_nucleation,set_abundances
 use options,        only:use_porosity,icooling,idamp
 use part,           only:apr_level,xyzh,vxyzu,npart,nden_nimhd,&
                          eos_vars,tau,tau_lucy,imu,igamma
 use units,        only:utime,udist,umass,unit_Bfield
 character(len=*), intent(in)  :: dumpfile,infile
 real,             intent(in)  :: time
 integer,          intent(out) :: ierr
 real :: gmw_nicil

 ierr = 0
 ! initialise apr if it is being used
 if (use_apr) call init_apr(apr_level,ierr)

 ! initialise values for non-ideal MHD
 if (mhd_nonideal) then
    call nicil_initialise(real(utime),real(udist),real(umass),real(unit_Bfield),ierr,iprint,iprint)
    if (ierr/=0) call fatal('initial','error initialising nicil (the non-ideal MHD library)')

    call use_consistent_gmw(ierr,gmw,gmw_nicil)
    if (ierr/=0) write(iprint,'(2(a,Es18.7))') &
       ' initial: Modifying mean molecular weight from ',gmw,' to ',gmw_nicil
 endif
 nden_nimhd = 0.0

 !
 ! initialise the equation of state
 ! (must be done AFTER the units are known & AFTER mu is calculated in non-ideal MHD)
 !
 call init_eos(ieos,ierr)
 if (ierr /= 0) call fatal('initial','error initialising equation of state')

 ! initialise turbulence driving
 if (driving) then
    if (id==master) write(iprint,*) 'waiting on input for turbulent driving...'
    call init_forcing(dumpfile,infile,time)
 endif
 !
 ! initialise dust
 !
 if (use_dust) then
    call init_drag(ierr)
    if (ierr /= 0) call fatal('initial','error initialising drag coefficients')
    if (use_dustgrowth) then
       call init_growth(ierr)
       if (ierr /= 0) call fatal('initial','error initialising growth variables')
       if (use_porosity) then
          call init_porosity(ierr)
          if (ierr /= 0) call fatal('initial','error initialising porosity variables')
          call init_filfac(npart,xyzh,vxyzu)
       endif
    endif
 endif
 !
 ! initialise cooling function
 ! this will initialise all cooling variables, including if h2chemistry = true
 !
 if (icooling > 0) call init_cooling(id,master,iprint,ierr)

 if (idamp > 0 .and. idamp < 3 .and. any(abs(vxyzu(1:3,:)) > tiny(0.)) .and. abs(time) < tiny(time)) then
    call error('setup','damping on: setting non-zero velocities to zero')
    vxyzu(1:3,:) = 0.
 endif

 ! initialise nucleation array, optical depth array, and Lucy optical depth array
 if (abs(time) <= tiny(0.)) then
    ! initialise nucleation array at the start of the run only
    if (do_nucleation) call init_nucleation
    ! initialise optical depth array tau
    if (itau_alloc == 1) tau = 0.
    ! initialise Lucy optical depth array tau_lucy
    if (itauL_alloc == 1) tau_lucy = 2./3.
 endif

! set gamma and mu arrays to the values from the infile
 if (update_muGamma) then
    eos_vars(igamma,:) = gamma
    eos_vars(imu,:) = gmw
    call set_abundances !to get mass_per_H
 endif

end subroutine initialise_physics_modules

!----------------------------------------------------------------
!+
!  Setup MHD and dustfrac evolution variables
!+
!----------------------------------------------------------------
subroutine get_density_and_initialise_conservative_variables()
 use dim,          only:mhd
 use densityforce, only:densityiterate
 use neighkdtree,  only:build_tree
 use options,      only:use_dustfrac
 use part,         only:npart,xyzh,vxyzu,Bevol,Bxyz,dustevol,dustfrac,&
                        rhoh,massoftype,iamtype,iphase,ndustsmall,fxyzu,&
                        fext,alphaind,divcurlv,divcurlB,gradh,rad,radprop,&
                        dvdx,apr_level
 integer :: i,itype
 real :: hi,pmassi,rhoi1,stressmax
 !
 !--The code works in B/rho as its conservative variable, but writes B to dumpfile
 !  So we now convert our primitive variable read, B, to the conservative B/rho
 !  This necessitates computing the density sum.
 !
 if (mhd .or. use_dustfrac) then
    if (npart > 0) then
       call build_tree(npart,npart,xyzh,vxyzu)
       fxyzu = 0.
       call densityiterate(2,npart,npart,xyzh,vxyzu,divcurlv,divcurlB,Bevol,stressmax,&
                              fxyzu,fext,alphaind,gradh,rad,radprop,dvdx,apr_level)
    endif

    ! now convert to B/rho
    do i=1,npart
       itype      = iamtype(iphase(i))
       hi         = xyzh(4,i)
       pmassi     = massoftype(itype)
       rhoi1      = 1.0/rhoh(hi,pmassi)
       if (mhd) then
          Bevol(1,i) = Bxyz(1,i) * rhoi1
          Bevol(2,i) = Bxyz(2,i) * rhoi1
          Bevol(3,i) = Bxyz(3,i) * rhoi1
       endif
       if (use_dustfrac) then
          !--sqrt(epsilon/1-epsilon) method (Ballabio et al. 2018)
          dustevol(:,i) = 0.
          dustevol(1:ndustsmall,i) = sqrt(dustfrac(1:ndustsmall,i)/(1.-dustfrac(1:ndustsmall,i)))
       endif
    enddo
 endif

end subroutine get_density_and_initialise_conservative_variables

!----------------------------------------------------------------
!+
!  Setup external forces
!+
!----------------------------------------------------------------
subroutine initialise_external_forces_and_gr(time,dtextforce,ierr)
 use dim,            only:gr,maxp,maxphase
 use io,             only:iprint,id,master,fatal
 use part,           only:npart,xyzh,vxyzu,fext,iphase,iamtype,iboundary,&
                          isdead_or_accreted,dens,metrics,metricderivs,pxyzu,&
                          fxyzu,alphaind,divcurlv,divcurlB,Bevol,gradh,&
                          rad,radprop,dvdx,apr_level
 use cons2prim,      only:prim2consall
 use densityforce,   only:densityiterate
 use externalforces, only:initialise_externalforces,externalforce,&
                          externalforce_vdependent,update_externalforce
 use extern_gr,      only:get_grforce_all
 use metric_tools,   only:imet_minkowski,imetric,init_metric
 use mpiutils,       only:reduceall_mpi
 use options,        only:iexternalforce
 use neighkdtree,    only:build_tree
 use timestep,       only:C_force
 real,    intent(in)    :: time
 real,    intent(inout) :: dtextforce
 integer, intent(out)   :: ierr
 integer :: i
 real :: poti,dtf,fextv(3),stressmax

 ierr = 0
 dtextforce = huge(dtextforce)
 fext(:,:)  = 0.

 if (gr) then
    ! --- Need rho computed by sum to do primitive to conservative, since dens is not read from file
    if (npart > 0) then
       call build_tree(npart,npart,xyzh,vxyzu)
       fxyzu = 0.
       call densityiterate(2,npart,npart,xyzh,vxyzu,divcurlv,divcurlB,Bevol,stressmax,&
                              fxyzu,fext,alphaind,gradh,rad,radprop,dvdx,apr_level)
    endif
    call init_metric(npart,xyzh,metrics,metricderivs)
    call prim2consall(npart,xyzh,metrics,vxyzu,pxyzu,use_dens=.false.,dens=dens)
    if (iexternalforce > 0 .and. imetric /= imet_minkowski) then
       call initialise_externalforces(iexternalforce,ierr)
       if (ierr /= 0) call fatal('initial','error in external force settings/initialisation')
       call get_grforce_all(npart,xyzh,metrics,metricderivs,vxyzu,fext,dtextforce,dens=dens)
    endif
 else
    if (iexternalforce > 0) then
       call initialise_externalforces(iexternalforce,ierr)
       call update_externalforce(iexternalforce,time,0.)
       if (ierr /= 0) call fatal('initial','error in external force settings/initialisation')
       !$omp parallel do default(none) &
       !$omp shared(npart,xyzh,vxyzu,fext,time,iexternalforce,C_force) &
       !$omp private(i,poti,dtf,fextv) &
       !$omp reduction(min:dtextforce)
       do i=1,npart
          if (.not.isdead_or_accreted(xyzh(4,i))) then
             call externalforce(iexternalforce,xyzh(1,i),xyzh(2,i),xyzh(3,i), &
                                xyzh(4,i),time,fext(1,i),fext(2,i),fext(3,i),poti,dtf,i)
             dtextforce = min(dtextforce,C_force*dtf)
             ! add velocity-dependent part
             call externalforce_vdependent(iexternalforce,xyzh(1:3,i),vxyzu(1:3,i),fextv,poti)
             fext(1:3,i) = fext(1:3,i) + fextv
          endif
       enddo
       !$omp end parallel do
    endif
 endif

 if (iexternalforce > 0) then
    dtextforce = reduceall_mpi('min',dtextforce)
    if (id==master) write(iprint,*) 'dt(extforce)  = ',dtextforce
 endif

 !-- Set external force to zero on boundary particles
 if (maxphase==maxp) then
!$omp parallel do default(none) &
!$omp shared(npart,fext,iphase) private(i)
    do i=1,npart
       if (iamtype(iphase(i))==iboundary) fext(:,i)=0.
    enddo
!$omp end parallel do
 endif

end subroutine initialise_external_forces_and_gr

!----------------------------------------------------------------
!+
!  Setup sink particles and calculate forces/timesteps
!+
!----------------------------------------------------------------
subroutine initialise_sink_particle_forces(time,dtextforce,dtsinkgas,logfile,ierr)
 use dim,              only:gr,maxptmass,use_sinktree,gravity,mpi,use_sinktree,maxpsph
 use part,             only:nptmass,xyzmh_ptmass,vxyz_ptmass,fxyz_ptmass,fxyz_ptmass_sinksink,&
                            epot_sinksink,dsdt_ptmass,npart,xyzh,massoftype,igas,get_ntypes,&
                            npartoftype,maxphase,maxp,use_apr,iphase,iamtype,aprmassoftype,&
                            apr_level,isdead_or_accreted,metrics_ptmass,metricderivs_ptmass,&
                            pxyzu_ptmass,fext,ibelong,fxyz_ptmass_tree,shortsinktree,isink,&
                            n_group,n_ingroup,n_sing,bin_info,group_info,nmatrix
 use ptmass,           only:get_accel_sink_gas,get_accel_sink_sink,h_acc,r_crit,r_crit2,&
                            rho_crit,rho_crit_cgs,r_merge_uncond,r_merge_cond,r_merge_uncond2,&
                            r_merge_cond2,r_merge2,init_ptmass,use_regnbody,icreate_sinks
 use timestep,         only:C_force
 use units,            only:unit_density
 use options,          only:iexternalforce
 use mpiutils,         only:reduce_in_place_mpi,reduceall_mpi
 use io,               only:iprint,id,master,nprocs
 use io_control,       only:set_rhofinal1
 use HIIRegion,        only:iH2R,initialize_H2R,update_ionrates
 use part,             only:isionised,ipert
 use subgroup,         only:subgroup_search,subgroup_init,update_kappa
 use utils_subgroup,   only:get_subgroup
 use metric_tools,     only:init_metric
 use cons2prim,        only:prim2consall
 use extern_gr,        only:get_grforce_all
 real,         intent(in)    :: time
 real,         intent(inout) :: dtextforce,dtsinkgas
 character(*), intent(in)    :: logfile
 integer,      intent(out)   :: ierr
 integer :: i,merge_n,merge_ij(maxptmass),ntypes
 integer :: boundi,boundf,sid,eid,gsize
 real    :: pmassi,fonrmax,dtphi2,dtsinksink,poti
 real, allocatable :: ponsubg(:)

 ierr = 0
 dtsinkgas = huge(dtsinkgas)
 r_crit2   = r_crit*r_crit
 rho_crit  = real(rho_crit_cgs/unit_density)
 r_merge_uncond2 = r_merge_uncond**2
 r_merge_cond2   = r_merge_cond**2
 r_merge2        = max(r_merge_uncond2,r_merge_cond2)
 call set_rhofinal1(unit_density)

 ! sink particles in the tree need an ibelong array
 if (use_sinktree) then
    if (mpi) then
       ibelong((maxpsph)+1:maxp) = -1
       boundi = (maxpsph)+(nptmass / nprocs)*id
       boundf = (maxpsph)+(nptmass / nprocs)*(id+1)
       if (id == nprocs-1) boundf = boundf + mod(nptmass,nprocs)
       ibelong(boundi+1:boundf) = id
    endif
    ! also set type of all sink particles in the tree to isink
    iphase(maxpsph+1:maxp) = isink
    shortsinktree = 1 ! init shortsinktree to 1 to avoid any problem if nptmass change during the calculation
    fxyz_ptmass_tree = 0.
 endif

 if (iH2R > 0 .and. id==master) then
    call initialize_H2R
 else
    isionised = .false.
 endif

 if (nptmass > 0) then
    if (id==master) write(iprint,"(a,i12)") ' nptmass       = ',nptmass
    if (iH2R > 0) call update_ionrates(nptmass,xyzmh_ptmass,h_acc)
    if (.not. gr) then
       ! compute initial sink-sink forces and get timestep
       if (use_regnbody) then
          call subgroup_init
          call subgroup_search(nptmass,n_group,n_ingroup,n_sing,xyzmh_ptmass,vxyz_ptmass,group_info,bin_info,nmatrix)
       endif
       call get_accel_sink_sink(nptmass,xyzmh_ptmass,fxyz_ptmass,epot_sinksink,dtsinksink,&
                               iexternalforce,time,merge_ij,merge_n,dsdt_ptmass,&
                               group_info,bin_info)
    endif

    if (gr) then
       ! calculate metric derivatives and external force from metric on sink particles
       call init_metric(nptmass,xyzmh_ptmass,metrics_ptmass,metricderivs_ptmass)
       call prim2consall(nptmass,xyzmh_ptmass,metrics_ptmass,&
                        vxyz_ptmass,pxyzu_ptmass,use_dens=.false.,use_sink=.true.)
       call get_grforce_all(nptmass,xyzmh_ptmass,metrics_ptmass,metricderivs_ptmass,&
                            vxyz_ptmass,fxyz_ptmass,dtextforce,use_sink=.true.)
       ! sinks in GR, provide external force due to metric to determine sink total force
       call get_accel_sink_sink(nptmass,xyzmh_ptmass,fxyz_ptmass_sinksink,epot_sinksink,dtsinksink,&
                                iexternalforce,time,merge_ij,merge_n,dsdt_ptmass)
       fxyz_ptmass = fxyz_ptmass + fxyz_ptmass_sinksink
    endif

    dtsinksink = C_force*dtsinksink
    if (id==master) write(iprint,*) 'dt(sink-sink) = ',dtsinksink
    dtextforce = min(dtextforce,dtsinksink)

    ! compute initial sink-gas forces and get timestep
    pmassi = massoftype(igas)
    ntypes = get_ntypes(npartoftype)
    allocate(ponsubg(nptmass))
    do i=1,npart
       if (.not.isdead_or_accreted(xyzh(4,i))) then
          if (ntypes > 1 .and. maxphase==maxp) then
             if (use_apr) then
                pmassi = aprmassoftype(iamtype(iphase(i)),apr_level(i))
             else
                pmassi = massoftype(iamtype(iphase(i)))
             endif
          elseif (use_apr) then
             pmassi = aprmassoftype(igas,apr_level(i))
          endif
          if (.not.use_sinktree) then
             call get_accel_sink_gas(nptmass,xyzh(1,i),xyzh(2,i),xyzh(3,i),xyzh(4,i),xyzmh_ptmass, &
                                     fext(1,i),fext(2,i),fext(3,i),poti,pmassi,fxyz_ptmass,&
                                     dsdt_ptmass,fonrmax,dtphi2,bin_info,ponsubg)
             dtsinkgas = min(dtsinkgas,C_force*1./sqrt(fonrmax),C_force*sqrt(dtphi2))
          endif
       endif
    enddo
    if (use_regnbody) bin_info(ipert,1:nptmass) = bin_info(ipert,1:nptmass) + ponsubg(1:nptmass)
    deallocate(ponsubg)

    ! reduction of sink-gas forces from each MPI thread
    call reduce_in_place_mpi('+',fxyz_ptmass(:,1:nptmass))

    if (id==master) write(iprint,*) 'dt(sink-gas)  = ',dtsinkgas

    dtextforce = min(dtextforce,dtsinkgas)
    !  Reduce dt over MPI tasks
    dtsinkgas = reduceall_mpi('min',dtsinkgas)
    dtextforce = reduceall_mpi('min',dtextforce)
    if (use_regnbody) then
       do i=1,n_group
          call get_subgroup(group_info,i,sid,eid,gsize)
          call update_kappa(xyzmh_ptmass,vxyz_ptmass,bin_info,group_info,sid,eid,gsize)
       enddo
    endif
 endif

 call init_ptmass(nptmass,logfile)

 if (gravity .and. icreate_sinks > 0) then
    dsdt_ptmass = 0. ! could introduce NaN in ptmass spins if not initialised (no get_accel done before creating sink)
    fxyz_ptmass = 0.
    fxyz_ptmass_sinksink = 0.
 endif

end subroutine initialise_sink_particle_forces

!----------------------------------------------------------------
!+
!  Setup initial derivatives calculation
!+
!----------------------------------------------------------------
subroutine get_derivs_initial(time,dumpfile,ntot,dtnew_first,ierr)
 use dim,              only:maxalpha,maxp,nalpha,do_radiation
 use part,             only:npart,xyzh,vxyzu,fxyzu,fext,divcurlv,divcurlB,Bevol,dBevol,&
                            rad,drad,radprop,dustprop,ddustprop,dustevol,ddustevol,filfac,&
                            dustfrac,eos_vars,pxyzu,dens,metrics,apr_level,alphaind
 use deriv,            only:derivs
 use timestep,         only:dtmax
#ifdef LIVE_ANALYSIS
 use analysis,         only:do_analysis
 use part,             only:igas,massoftype
 use fileutils,        only:numfromfile
 use io,               only:ianalysis
 use radiation_utils,  only:set_radiation_and_gas_temperature_equal
#endif
 real,         intent(in)  :: time
 character(*), intent(in)  :: dumpfile
 integer(kind=8), intent(in)  :: ntot
 real,         intent(out) :: dtnew_first
 integer,      intent(out) :: ierr
 integer :: i,j,nderivinit,ialphaloc

 ierr = 0
 dtnew_first = dtmax  ! necessary in case ntot = 0
 nderivinit  = 1
 ! call derivs twice with Cullen-Dehnen switch to update accelerations
 if (maxalpha==maxp .and. nalpha >= 0) nderivinit = 2

 !$omp parallel do default(none) &
 !$omp shared(npart,eos_vars,fxyzu) &
 !$omp private(i)
 do i=1,npart
    eos_vars(3,i) = -1.0 ! initial guess for temperature overridden in eos
    fxyzu(:,i) = 0.      ! so that div_a is 0 in first call to viscosity switch
 enddo
 !$omp end parallel do

 do j=1,nderivinit
    if (ntot > 0) call derivs(1,npart,npart,xyzh,vxyzu,fxyzu,fext,divcurlv,divcurlB,Bevol,dBevol,&
                              rad,drad,radprop,dustprop,ddustprop,dustevol,ddustevol,filfac,&
                              dustfrac,eos_vars,time,0.,dtnew_first,pxyzu,dens,metrics,apr_level)
#ifdef LIVE_ANALYSIS
    call do_analysis(dumpfile,numfromfile(dumpfile),xyzh,vxyzu, &
                     massoftype(igas),npart,time,ianalysis)
    call derivs(1,npart,npart,xyzh,vxyzu,fxyzu,fext,divcurlv,divcurlB,&
                Bevol,dBevol,rad,drad,radprop,dustprop,ddustprop,dustevol,&
                ddustevol,filfac,dustfrac,eos_vars,time,0.,dtnew_first,pxyzu,dens,metrics,apr_level)

    if (do_radiation) call set_radiation_and_gas_temperature_equal(npart,xyzh,vxyzu,massoftype,rad)
#endif
 enddo

 if (nalpha >= 2) then
    ialphaloc = 2
    !$omp parallel do private(i)
    do i=1,npart
       alphaind(1,i) = max(alphaind(1,i),alphaind(ialphaloc,i)) ! set alpha = max(alphaloc,alpha)
    enddo
 endif

end subroutine get_derivs_initial

!----------------------------------------------------------------
!+
!  compute energies and initialise evolution (.ev) output files
!+
!----------------------------------------------------------------
subroutine get_energies_and_init_ev_files(infile,evfile,logfile,time,dt)
 use evwrite,          only:init_evfile,write_evfile,write_evlog
 use io,               only:id,master,iprint,ievfile
 use options,          only:write_files
#ifdef MFLOW
 use mf_write,         only:mflow_write,mflow_init
 use io,               only:imflow
#endif
#ifdef VMFLOW
 use mf_write,         only:vmflow_write,vmflow_init
 use io,               only:ivmflow
#endif
#ifdef BINPOS
 use mf_write,         only:binpos_write,binpos_init
 use io,               only:ibinpos
#endif
 character(len=*), intent(in)  :: infile,evfile,logfile
 real,             intent(in)  :: time,dt

 if (write_files) call init_evfile(ievfile,evfile,.true.)
 call write_evfile(time,dt)
 if (write_files .and. id==master) call write_evlog(iprint)
#ifdef MFLOW
 if (write_files) call mflow_init(imflow,evfile,infile) !take evfile in input to create string.mf
 if (write_files) call mflow_write(time, dt)
#endif

#ifdef VMFLOW
 if (write_files) call vmflow_init(ivmflow,evfile,infile) !take evfile in input to create string_v.mflowv
 if (write_files) call vmflow_write(time, dt)
#endif

#ifdef BINPOS
 if (write_files) call binpos_init(ibinpos,evfile) !take evfile in input to create string.binpos
 if (write_files) call binpos_write(time, dt)
#endif

end subroutine get_energies_and_init_ev_files

!----------------------------------------------------------------
!+
!  Setup conservation tracking
!+
!----------------------------------------------------------------
subroutine init_conservation_checks()
 use dim,            only:use_dust
 use io,             only:id,master,iprint,iverbose,warning
 use checkconserved, only:get_conserv,etot_in,angtot_in,totmom_in,mdust_in,mtot_in
 use energies,       only:etot,angtot,totmom,mdust,mtot
 use fileutils,      only:make_tags_unique
 use part,           only:ndusttypes
 real :: tolu,toll
 character(len=7)  :: dust_label(ndusttypes)
 integer :: i

 !  set initial values for continual verification of conservation laws
 !  get_conserve=0.5: update centre of mass only; get_conserve=1: update all; get_conserve=-1: update none
 !
 if (get_conserv > 0.0) then
    etot_in   = etot
    angtot_in = angtot
    totmom_in = totmom
    mdust_in  = mdust
    mtot_in   = mtot
    if (id==master .and. iverbose >= 1) then
       write(iprint,'(1x,a)') 'Setting initial values to verify conservation laws:'
    endif
 else
    if (id==master .and. iverbose >= 1) then
       write(iprint,'(1x,a)') 'Reading initial values to verify conservation laws from previous run:'
    endif
 endif
 if (id==master) then
    if (iverbose >= 1) then
       write(iprint,'(1x,a,es18.6)') 'Initial total energy:     ', etot_in
       write(iprint,'(1x,a,es18.6)') 'Initial angular momentum: ', angtot_in
       write(iprint,'(1x,a,es18.6)') 'Initial linear momentum:  ', totmom_in
       write(iprint,'(1x,a,es18.6)') 'Initial total mass:  ', mtot_in
    endif
    if (use_dust) then
       dust_label = 'dust'
       call make_tags_unique(ndusttypes,dust_label)
       do i=1,ndusttypes
          if (mdust_in(i) > 0.) write(iprint,'(1x,a,es18.6)') 'Initial '//trim(dust_label(i))//' mass:     ',mdust_in(i)
       enddo
       write(iprint,'(1x,a,es18.6)') 'Initial total dust mass:', sum(mdust_in(:))
    endif
 endif
 !
 !--Print warnings of units if values are not reasonable
 !
 tolu = 1.0e2
 toll = 1.0e-2
 if (get_conserv > 0.0) then
    get_conserv = -1.
    if (id==master) then
       if (abs(etot_in) > tolu ) call warning('initial',&
          'consider changing units to reduce abs(total energy)',var='etot',val=etot_in)
       if (mtot > tolu .or. mtot < toll)  call warning('initial',&
          'consider changing units so total mass is closer to unity',var='mtot',val=mtot)
    endif
 endif

end subroutine init_conservation_checks

!----------------------------------------------------------------
!+
!  Write initial dump file (replacing .tmp) and update infile
!+
!----------------------------------------------------------------
subroutine write_initial_dump(time,dumpfile,infile,logfile,evfile)
 use io,               only:id,master,iprint,idisk1,iwritein
 use readwrite_dumps,  only:write_fulldump
 use readwrite_infile, only:write_infile
 use mpiutils,         only:barrier_mpi
 use options,          only:write_files
 character(len=*), intent(in)    :: infile,evfile,logfile
 character(len=*), intent(inout) :: dumpfile
 real,             intent(in)    :: time
 character(len=len(dumpfile)) :: dumpfileold
 integer :: ipostmp
 logical :: iexist
 !
 ! write initial conditions to output file
 ! if the input file ends in .tmp
 !
 if (write_files) then
    ipostmp  = index(dumpfile,'.tmp')
    if (ipostmp > 0) then
       dumpfileold = dumpfile
       dumpfile = trim(dumpfile(1:ipostmp-1))
       call write_fulldump(time,trim(dumpfile))
       if (id==master) call write_infile(infile,logfile,evfile,trim(dumpfile),iwritein,iprint)
       !
       !  delete temporary dump file dump_00000.tmp if it exists
       !
       call barrier_mpi() ! Ensure all procs have read temp file before deleting
       inquire(file=trim(dumpfileold),exist=iexist)
       if (id==master .and. iexist) then
          write(iprint,"(/,a,/)") ' ---> DELETING temporary dump file '//trim(dumpfileold)//' <---'
          open(unit=idisk1,file=trim(dumpfileold),status='old')
          close(unit=idisk1,status='delete')
       endif
    endif
 endif

end subroutine write_initial_dump

!----------------------------------------------------------------
!+
!  Reset or deallocate things that were allocated in initialise
!+
!----------------------------------------------------------------
subroutine finalise()
 use dim, only:mpi
 use mpitree, only:finish_tree_comms
 use mpimemory, only:deallocate_mpi_memory

 if (mpi) then
    call finish_tree_comms()
    call deallocate_mpi_memory()
 endif

end subroutine finalise

!----------------------------------------------------------------
!+
!  This module ends the run (prints footer and closes log).
!  Only called by master thread.
!+
!----------------------------------------------------------------
subroutine endrun
 use io,       only:iprint,ievfile,iscfile,imflow,ivmflow,ibinpos,igpos
 use timing,   only:printused
 use part,     only:nptmass
 use eos,      only:ieos,finish_eos
 use ptmass,   only:finish_ptmass
 integer           :: ierr
 character(len=10) :: finishdate, finishtime

 call finalise()
 call finish_eos(ieos,ierr)

 write (iprint,"(/,'>',74('_'),'<')")
!
!--print time and date of finishing
!
 call date_and_time(finishdate,finishtime)
 finishdate = finishdate(7:8)//'/'//finishdate(5:6)//'/'//finishdate(1:4)
 finishtime = finishtime(1:2)//':'//finishtime(3:4)//':'//finishtime(5:)
 write(iprint,"(/,' Run finished on ',a,' at ',a,/)") finishdate,finishtime
!
!--print out total code timings:
!
 call printused(twall_start,'Total wall time:',iprint)

 write(iprint,40)
40 format(/, &
   6x,' |   |           |               | |   _|       | |         ',/, &
   6x,' __| __ \   _` | __|  __|   _` | | |  |    _ \  | |  /  __| ',/, &
   6x,' |   | | | (   | |  \__ \  (   | | |  __| (   | |   < \__ \ ',/, &
   6x,'\__|_| |_|\__,_|\__|____/ \__,_|_|_| _|  \___/ _|_|\_\____/ ',/)

 write (iprint,"('>',74('_'),'<')")
!
!--close ev, log and ptmass-related files
!
 close(unit=ievfile)
 close(unit=imflow)  ! does not matter if not open
 close(unit=ivmflow)
 close(unit=ibinpos)
 close(unit=igpos)
 if (iprint /= 6) close(unit=iprint)

 if (iscfile > 0) close(unit=iscfile)

 call finish_ptmass(nptmass)

end subroutine endrun

end module initial
