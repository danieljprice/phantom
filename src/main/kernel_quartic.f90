!--------------------------------------------------------------------------!
! The Phantom Smoothed Particle Hydrodynamics code, by Daniel Price et al. !
! Copyright (c) 2007-2021 The Authors (see AUTHORS)                        !
! See LICENCE file for usage and distribution conditions                   !
! http://phantomsph.bitbucket.io/                                          !
!--------------------------------------------------------------------------!
module kernel
!
! This module implements the M_5 quartic kernel
!   DO NOT EDIT - auto-generated by kernels.py
!
! :References: None
!
! :Owner: Daniel Price
!
! :Runtime parameters: None
!
! :Dependencies: physcon
!
 use physcon, only:pi
 implicit none
 character(len=11), public :: kernelname = 'M_5 quartic'
 real, parameter, public  :: radkern  = 2.5
 real, parameter, public  :: radkern2 = 6.25
 real, parameter, public  :: cnormk = 0.05/pi
 real, parameter, public  :: wab0 = 14.375, gradh0 = -3.*wab0
 real, parameter, public  :: dphidh0 = 1199./960.
 real, parameter, public  :: cnormk_drag = 1./(23.*pi)
 real, parameter, public  :: hfact_default = 1.1
 real, parameter, public  :: av_factor = 35783./26880.

contains

pure subroutine get_kernel(q2,q,wkern,grkern)
 real, intent(in)  :: q2,q
 real, intent(out) :: wkern,grkern
 real :: q4

 !--M_5 quartic
 if (q < 0.5) then
    q4 = q2*q2
    wkern  = 6.*q4 - 15.*q2 + 14.375
    grkern = q*(24.*q2 - 30.)
 elseif (q < 1.5) then
    wkern  = (q - 2.5)**4 - 5.*(q - 1.5)**4
    grkern = -16.*q2*q + 60.*q2 - 60.*q + 5.
 elseif (q < 2.5) then
    wkern  = (q - 2.5)**4
    grkern = 4.*(q - 2.5)**3
 else
    wkern  = 0.
    grkern = 0.
 endif

end subroutine get_kernel

pure elemental real function wkern(q2,q)
 real, intent(in) :: q2,q
 real :: q4

 if (q < 0.5) then
    q4 = q2*q2
    wkern = 6.*q4 - 15.*q2 + 14.375
 elseif (q < 1.5) then
    wkern = (q - 2.5)**4 - 5.*(q - 1.5)**4
 elseif (q < 2.5) then
    wkern = (q - 2.5)**4
 else
    wkern = 0.
 endif

end function wkern

pure elemental real function grkern(q2,q)
 real, intent(in) :: q2,q

 if (q < 0.5) then
    grkern = q*(24.*q2 - 30.)
 elseif (q < 1.5) then
    grkern = -16.*q2*q + 60.*q2 - 60.*q + 5.
 elseif (q < 2.5) then
    grkern = 4.*(q - 2.5)**3
 else
    grkern = 0.
 endif

end function grkern

pure subroutine get_kernel_grav1(q2,q,wkern,grkern,dphidh)
 real, intent(in)  :: q2,q
 real, intent(out) :: wkern,grkern,dphidh
 real :: q4, q6

 if (q < 0.5) then
    q4 = q2*q2
    q6 = q4*q2
    wkern  = 6.*q4 - 15.*q2 + 14.375
    grkern = q*(24.*q2 - 30.)
    dphidh = -q6/5. + 3.*q4/4. - 23.*q2/16. + 1199./960.
 elseif (q < 1.5) then
    q4 = q2*q2
    q6 = q4*q2
    wkern  = (q - 2.5)**4 - 5.*(q - 1.5)**4
    grkern = -16.*q2*q + 60.*q2 - 60.*q + 5.
    dphidh = 2.*q6/15. - 4.*q4*q/5. + 3.*q4/2. - q2*q/3. - 11.*q2/8. + 599./480.
 elseif (q < 2.5) then
    q4 = q2*q2
    q6 = q4*q2
    wkern  = (q - 2.5)**4
    grkern = 4.*(q - 2.5)**3
    dphidh = -q6/30. + 2.*q4*q/5. - 15.*q4/8. + 25.*q2*q/6. - 125.*q2/32. + 625./384.
 else
    wkern  = 0.
    grkern = 0.
    dphidh = 0.
 endif

end subroutine get_kernel_grav1

pure subroutine kernel_softening(q2,q,potensoft,fsoft)
 real, intent(in)  :: q2,q
 real, intent(out) :: potensoft,fsoft
 real :: q4, q6

 if (q < 0.5) then
    q4 = q2*q2
    q6 = q4*q2
    potensoft = q6/35. - 3.*q4/20. + 23.*q2/48. - 1199./960.
    fsoft     = q*(144.*q4 - 504.*q2 + 805.)/840.
 elseif (q < 1.5) then
    q4 = q2*q2
    q6 = q4*q2
    potensoft = (2.*q*(-64.*q6 + 448.*q4*q - 1008.*q4 + 280.*q2*q + 1540.*q2 - 4193.) - &
                 1.)/(6720.*q)
    fsoft     = (-768.*q6*q + 4480.*q6 - 8064.*q4*q + 1680.*q4 + 6160.*q2*q + &
                 1.)/(6720.*q2)
 elseif (q < 2.5) then
    q4 = q2*q2
    q6 = q4*q2
    potensoft = (q*(64.*q6 - 896.*q4*q + 5040.*q4 - 14000.*q2*q + 17500.*q2 - 21875.) + &
                 2185.)/(13440.*q)
    fsoft     = (384.*q6*q - 4480.*q6 + 20160.*q4*q - 42000.*q4 + 35000.*q2*q - &
                 2185.)/(13440.*q2)
 else
    potensoft = -1./q
    fsoft     = 1./q2
 endif

end subroutine kernel_softening

!------------------------------------------
! double-humped version of the kernel for
! use in drag force calculations
!------------------------------------------
pure elemental real function wkern_drag(q2,q)
 real, intent(in) :: q2,q
 real :: q4

 !--double hump M_5 quartic kernel
 if (q < 0.5) then
    q4 = q2*q2
    wkern_drag = q2*(6.*q4 - 15.*q2 + 14.375)
 elseif (q < 1.5) then
    wkern_drag = q2*((q - 2.5)**4 - 5.*(q - 1.5)**4)
 elseif (q < 2.5) then
    wkern_drag = q2*(q - 2.5)**4
 else
    wkern_drag = 0.
 endif

end function wkern_drag

end module kernel
